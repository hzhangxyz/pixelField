<script src="./common-interface.js"></script>
<script src="./local-storage-interface.js"></script>
<script src="https://cdn.bootcss.com/two.js/0.7.0-alpha.1/two.min.js"></script>
<script src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>

<!--<script src="./local-storage-interface-test.js"></script>-->

<body>
  <div id="loading"><p style="margin: 0;position: fixed">loading.<span id=dots></span></p></div>
  <div id="loaded" style="display: none">
    <div id=container tabindex=1></div>
    <div id=picker style="padding: 5;position: fixed;">
      <input type=color id=color></input>
      <button id=button>color it</button>
      <button id=clear>clear all</button>
      <span id=position></span>
    </div>
  </div>
</body>

<script>

var dotter = setInterval(()=>{$("#dots").append(".")},300);

// 准备画布
var params = {
  fullscreen: true,
  type: Two.Types.svg,
//  autostart: true
};
var two = new Two(params).appendTo(document.getElementById("container"));

var unitSize = 20;
var cacheParam = 2
var offsetX = two.width/2;
var offsetY = two.height/2;

var tmpOffsetX = 0;
var tmpOffsetY = 0;
var startX = 0;
var startY = 0;
var selectX = 0;
var selectY = 0;

var toSend = [];
var ws = null;

// 读取url中信息
if(location.search.length>1){
  unitSize = parseInt(location.search.substr(1))
}
if(location.hash.length>1){
  [selectX, selectY] = location.hash.substr(1).split(",").map((n)=>parseInt(n))
  offsetX -= selectX*unitSize
  offsetY -= selectY*unitSize
}

// 更新画布位置
var group = two.makeGroup();
var selectRect = two.makeRectangle(0, 0, unitSize, unitSize);
selectRect.fill = "rgba(256, 0, 0, 0)";

two.bind('update',()=>{
  group.translation.set(offsetX, offsetY);
  //var oldSelectRect = selectRect;
  //selectRect.fill = "rgba(256, 0, 0, 0)";
  selectRect.translation.set(selectX*unitSize+offsetX, selectY*unitSize+offsetY);
  //oldSelectRect.remove();
})

// 更新画布内容
function createPoint(x, y, r, g, b, group, two){
  var rect = two.makeRectangle(x*unitSize, y*unitSize, unitSize, unitSize);
  rect.fill = `rgb(${r},${g},${b})`
  rect.noStroke()
  group.add(rect)
}

function getRange(){
  var w = two.width/unitSize;
  var h = two.height/unitSize;
  var x = -offsetX/unitSize;
  var y = -offsetY/unitSize;
  res = [ x - cacheParam*w, y - cacheParam*h, x + (1+cacheParam)*w, y + (1+cacheParam)*h ]
  return res
}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function clearCanvas(){
  clearData(localStorage);
  tree = createTree(LocalStorageTreeNode,localStorage);
  freshCanvas()
}

async function freshCanvas(){
  if(!tree){
    console.log("Read From Storage")
    tree = await recovery(localStorage);
    if(!tree){
      tree = createTree(LocalStorageTreeNode,localStorage);
    }
  }
  var l = await tree.query(...getRange());
  var g = group.children.map((n)=>n)
  for(var i of l){
    createPoint(i.x,i.y,i.r,i.g,i.b,group,two);
  }
  g.map((n)=>n.remove());
  two.update()
  //await sleep(2000)
}

//拖动的时候...

$("#position").html(`X: ${selectX}, Y: ${selectY}`);
$("#container").bind("mousedown",function(e){
  selectX = Math.round((e.pageX - offsetX)/unitSize);
  selectY = Math.round((e.pageY - offsetY)/unitSize);
  location.hash=`${selectX},${selectY}`;
  $("#position").html(`X: ${selectX}, Y: ${selectY}`);
  startX=e.pageX;
  startY=e.pageY;
  tmpOffsetX = offsetX;
  tmpOffsetY = offsetY;
  two.update()
  $("#container").bind("mousemove",function(es){
    offsetX = es.pageX - startX + tmpOffsetX
    offsetY = es.pageY - startY + tmpOffsetY
    two.update()
  });
})
$("#container").bind("mouseup",function(e){
  $("#container").unbind("mousemove")
})

//color it
function colorIt(){
  var color = $("#color").val();
  //tree.addPoint
  clientAddPoint({x:selectX,y:selectY},{
    r:parseInt(color.substr(1,2),16),
    g:parseInt(color.substr(3,2),16),
    b:parseInt(color.substr(5,2),16)
  },Date.now())
  freshCanvas()
}
$("#button").click(colorIt)
$("#clear").click(clearCanvas)

//一些键盘操作
$("#container").bind("keydown",function(e) {
  switch(e.keyCode){
    case 32://空格
      colorIt()
      break;
    case 37://left
      selectX -= 1;
      break;
    case 38://up
      selectY -= 1;
      break;
    case 39://right
      selectX += 1;
      break;
    case 40://down
      selectY += 1;
      break;
  }
  $("#position").html(`X: ${selectX}, Y: ${selectY}`);
  two.update()
});

//来自服务器的更新

async function loaded(){
  $("#loaded").css("display","block")
  $("#loading").css("display","none")
  clearInterval(dotter)
  $("#container").focus()
}

function clientAddPoint(){
  tree.addPoint(...arguments)
  toSend.push(arguments)
  //
  Client2Server()
}

async function loadFromServer(){

  //send toSend
  //ask update
  await freshCanvas();
}

// Loading Local Storage

function Server2Client(){
  ws.send(JSON.stringify({time: 0, x1:-100, y1:-100, x2:100, y2:100}));
}

function Client2Server(){
  ws.send(JSON.stringify(toSend))
  toSend = []
}

async function loader(){
  await freshCanvas();

  ws = new WebSocket(location.origin.replace("http","ws"));

  // time 由当前区域tree的信息确定 同时传递x y z
  ws.onmessage = function(evt) {
    console.log(JSON.parse(evt.data))
    for(var i of JSON.parse(evt.data)){
      tree.addPoint({x:i.x,y:i.y},{r:i.r,g:i.g,b:i.b},i.t)
    }
  };

  ws.onclose = function(evt) {
    console.log('Connection closed.');
    ws = new WebSocket(location.origin.replace("http","ws"));
  };

  ws.onopen = function(evt) {
    console.log('Connection open ...');
    ws.send(JSON.stringify({time: 0, x1:-100, y1:-100, x2:100, y2:100}));
  };
}

var tree = null;
loader().then(()=>{
  loaded();
}).then(()=>{
  setInterval(()=>loadFromServer(),1000)
})


</script>

